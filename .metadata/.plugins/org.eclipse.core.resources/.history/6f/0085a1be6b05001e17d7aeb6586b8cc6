/*
 * RTCDriver.c
 *
 *  Created on: 7/06/2023
 *      Author: santiago
 */

#include "RTCDriver.h"


/* Driver RTC utilizando el cristal de baja velocidad LSE*/

// Definicion de arreglos para leer la hora y los datos del calendario
uint8_t time[6] = {0};
uint8_t date[5] = {0};

// Variables para almacenar los datos de tiempo
uint8_t RTC_HoursU   = 0;
uint8_t RTC_HoursT   = 0;
uint8_t RTC_MinutesU = 0;
uint8_t RTC_MinutesT = 0;
uint8_t RTC_SecondsU = 0;
uint8_t RTC_SecondsT = 0;
uint8_t RTC_AmPm 	 = 0;

//Definicion de variables para almacenar los datos de calendario
uint8_t RTC_dayU 	 = 0;
uint8_t RTC_dayT  	 = 0;
uint8_t RTC_month    = 0;
uint8_t RTC_yearU	 = 0;
uint8_t RTC_yearT 	 = 0;
uint8_t RTC_wdu      = 0;

// Funcion que configura el RTC con el cristal LSE
void rtc_Config(RTC_Handler_t *ptrRTCHandler){

	/*Es necesario habilitar el reloj del APB1 donde se encuentra el periferico RTC. Además,
	 *se habilita el acceso de escritura porque el periferico se encuentra protegido
	 */
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_DBP;

	RCC->BDCR |= RCC_BDCR_RTCEN;    // Se activa la señal de reloj
	RCC->BDCR |= RCC_BDCR_LSEON;    // Se activa el cristal LSE
	RCC->BDCR |= RCC_BDCR_RTCSEL_0; // Se selecciona el LSE como fuente del RTC

	// Se espera hasta que el LSE este listo
	while(!(RCC->BDCR & RCC_BDCR_LSERDY));

	 /* Se ingresan las claves dadas por el fabricante en el registro de proteccion contra
	 * escritura
	 */

    RTC->WPR |= 0xCA;
    RTC->WPR |= 0x53;

    // Se entra en el modo de inicializacion
    RTC->ISR |= RTC_ISR_INIT;

    // Se espera a que se active este modo
    while(!(RTC->ISR & RTC_ISR_INITF));

    //Se configuran los prescaler para obtener 1 Hz, 127 para el asincrono y 255 para el sincrono.
    //32768 Hz / (127 +1) = 256 Hz
    //256 Hz /(255 + 1) = 1 Hz

    RTC->PRER |= 127 << RTC_PRER_PREDIV_A_Pos;
    RTC->PRER |= 255 << RTC_PRER_PREDIV_S_Pos;


    //Se configura el RTC para que tome valores de los contadores del calendario

    RTC->CR |= RTC_CR_BYPSHAD;

    // Se reinician los contadores del calendario
    RTC->TR = 0;
    RTC->DR = 0;

    // Elegimos el formato de hora AM/PM
    RTC->CR |= RTC_CR_FMT;

    /* El registro time register esta en formato BCD. se realiza la division y el modulo para
     * obtener decenas y unidades.
     */

    RTC->TR |= ptrRTCHandler->RTC_Hours/10 << RTC_TR_HT_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Hours%10 << RTC_TR_HU_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Minutes/10 << RTC_TR_MNT_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Minutes%10 << RTC_TR_MNU_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Seconds/10  << RTC_TR_ST_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Seconds%10 << RTC_TR_SU_Pos;

    //Para el formato AM-PM
    RTC->TR |= ptrRTCHandler->RTC_AmPm << RTC_TR_PM_Pos;

    /* El registro RTC date register se encuentra en formato BCD,se realiza la division y
     * el modulo para obtener decenas y unidades.
     */

    RTC->DR |= ptrRTCHandler->RTC_Months%10 << RTC_DR_MU_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Months/10 << RTC_DR_MT_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Days/10 << RTC_DR_DT_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Days%10 << RTC_DR_DU_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Wdu<< RTC_DR_WDU_Pos;

    /*El sistema por defecto tiene la fecha del año 2000, de este modo se resta 2000 al valor del handler
     * y se realiza la separacion de decenas y unidades porque los años se encuentran en formato BCD.
     */
    RTC->DR |= ((ptrRTCHandler->RTC_Years -2000)%10) << RTC_DR_YU_Pos;
    RTC->DR |= (ptrRTCHandler->RTC_Years - 2000)/10 << RTC_DR_YT_Pos;

    // Activamos nuevamente el real time clock
    RCC->BDCR |= RCC_BDCR_RTCEN;

    // Salimos del modo de inicializacion borrando el bit de inicio
    RTC->ISR &= ~RTC_ISR_INIT;

    // Se habilita la proteccion de bits
    PWR->CR &= ~ PWR_CR_DBP;

    // Escribir una clave incorrecta reactiva la protección contra escritura
    RTC->WPR = (0xFF);

}// Fin config_RTC

// Funcion que entrega un puntero para almacenar los resultados en el arreglo Time
uint8_t* read_Time(void){

	/*Extraemos el dato de los registros haciendo uso de una mascara y lo desplazamos a
	 * la primera posicion
	*/
	RTC_HoursU = ((RTC->TR & RTC_TR_HU_Msk)>>RTC_TR_HU_Pos);
    RTC_HoursT = ((RTC->TR & RTC_TR_HT_Msk)>> RTC_TR_HT_Pos);
    RTC_MinutesU = ((RTC->TR & RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos);
    RTC_MinutesT = ((RTC->TR & RTC_TR_MNT_Msk)>>RTC_TR_MNT_Pos);
    RTC_SecondsU = ((RTC->TR & RTC_TR_SU_Msk)>>RTC_TR_SU_Pos);
    RTC_SecondsT = ((RTC->TR & RTC_TR_ST_Msk)>>RTC_TR_ST_Pos);

    //formato AM-PM
    RTC_AmPm = ((RTC->TR & RTC_TR_PM_Msk)>>RTC_TR_PM_Pos);

    //Se almacenan los datos en el arreglo
    time[0] = RTC_SecondsU;
    time[1] = RTC_SecondsT;
    time[2] = RTC_MinutesU;
    time[3] = RTC_MinutesT;
    time[4] = RTC_HoursU;
    time[5] = RTC_HoursT;
    time[6] = RTC_AmPm;

     return time;

}

// Funcion que entrega un puntero para almacenar los resultados en el arreglo Date
uint8_t* read_Date(void){

	/*Extraemos el dato de los registros haciendo uso de una mascara y lo desplazamos a
	 * la primera posicion
	 */

	// Para los dias
    RTC_dayT = ((RTC->DR & RTC_DR_DT_Msk)>> RTC_DR_DT_Pos);
    RTC_dayU = ((RTC->DR & RTC_DR_DU_Msk)>>RTC_DR_DU_Pos);

    //Para el año
    RTC_yearU = ((RTC->DR & RTC_DR_YU_Msk)>>RTC_DR_YU_Pos);
    RTC_yearT = ((RTC->DR & RTC_DR_YT_Msk)>>RTC_DR_YT_Pos);

    //Para el mes
    RTC_month = (((RTC->DR & RTC_DR_MT_Msk)>>RTC_DR_MT_Pos)*10) + (((RTC->DR & RTC_DR_MU_Msk)>>RTC_DR_MU_Pos)%10);

    // Dias de la semana
    RTC_wdu = (RTC->DR & RTC_DR_WDU_Msk)>>RTC_DR_WDU_Pos;

    // Se almacenan los datos en el arreglo date
    date[0] = RTC_dayU;
    date[1] = RTC_dayT;
    date[2] = RTC_month;
    date[3] = RTC_yearU;
    date[4] = RTC_yearT;
    date[5] = RTC_wdu;

    return date;

}// Fin funcion readDate


