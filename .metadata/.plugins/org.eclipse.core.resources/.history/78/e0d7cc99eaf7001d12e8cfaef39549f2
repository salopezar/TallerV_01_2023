/**
 ******************************************************************************
 * @file           : main.c
 * @author         : SANTIAGO LÓPEZ ARANZAZU - CC. 1007429871
 * @e-mail         : salopezar@unal.edu.co
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************************** TAREA ESPECIAL ********************************/
/*
 * Este programa busca unificar algunas ideas y conceptos trabajados en el
 * curso de taller 5 anteriormente, a través de la integración de algunos drivers
 * que muestran la introducción a algunos protocolos de comunicación como USART e
 * I2C y la generación de señales PWM para el control de algunos dispositivos
 * externos al microcontrolador mediante señales cuadradas con características de
 * frecuencia y anchos de pulso determinados por lecturas de sensores externos o
 * de acuerdo al criterio que se requiera.
 *
 * Además, se implementa un nuevo driver que permite variar la frecuencia natural
 * de funcionamiento de 16 MHz del microcontrolador (PLL), que a su vez, obliga a
 * cambiar algunas frecuencias de transmisión en los protocolos de comunicación con
 */


#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

#include <stm32f4xx.h>

#include "BasicTimer.h"
#include "GPIOxDriver.h"
#include "ExtiDriver.h"
#include "USARTxDriver.h"
#include "SysTickDriver.h"
#include "PwmDriver.h"
#include "PLLDriver.h"

// Se define y se inicializa el LED de estado.
GPIO_Handler_t handlerBlinkyPin = {0};
// Definición del timer para el Blinky.// Se define y se inicializa el LED de estado.
GPIO_Handler_t handlerBlinkyPin = {0};
// Definición del timer para el Blinky.
BasicTimer_Handler_t handlerTim2 = {0};
BasicTimer_Handler_t handlerTim2 = {0};

void init_hardware(void);
void BasicTimer2_Callback(void);


int main(void){

	init_hardware();

    while(1){

    }

}

void init_Hardware(void){


	/* Configuración del LED de estado que indica el funcionamiento del programa */
	handlerBlinkyPin.pGPIOx 									= GPIOA;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinNumber 				= PIN_5;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinSpeed  				= GPIO_OSPEED_FAST;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;

	// Se carga lo que se hizo sobre el pin A5 sobre el que está el blinkyPin
	GPIO_Config(&handlerBlinkyPin);
	GPIO_WritePin(&handlerBlinkyPin, SET);

	// Configuración general en que se va a manejar el timer del blinky.
	handlerTim2.ptrTIMx								= TIM2;
	handlerTim2.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
	handlerTim2.TIMx_Config.TIMx_speed				= BTIMER_SPEED_1ms;
	handlerTim2.TIMx_Config.TIMx_period				= 250; //Lanza una interrupcion cada 250 ms
	handlerTim2.TIMx_Config.TIMx_interruptEnable 	= BTIMER_INTERRUPT_ENABLE;

	/* Se carga ahora la configuración del TIMER */
	BasicTimer_Config(&handlerTim2);
}

// Basic timer sobre el que está puesto el led de estado.
void BasicTimer2_Callback(void){
	GPIOxTooglePin(&handlerBlinkyPin);
}


