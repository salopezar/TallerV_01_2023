/**
 ******************************************************************************
 * @file           : main.c
 * @author         : SANTIAGO LÓPEZ ARANZAZU - CC. 1007429871
 * @e-mail         : salopezar@unal.edu.co
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


/* Cabeceras de las librerías */
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include "stm32f4xx.h"
#include <string.h>


/* Cabeceras de los drivers */
#include "ExtiDriver.h"
#include "GPIOxDriver.h"
#include "PLLDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "adcDriver.h"
#include "PwmDriver.h"
#include "I2CDriver.h"
#include "RTCDriver.h"

// Definición de los handlers GPIO necesarios.
GPIO_Handler_t handlerStateLED				= {0};
GPIO_Handler_t handlerUSARTPINTX			= {0};
GPIO_Handler_t handlerUSARTPINRX			= {0};
GPIO_Handler_t HandlerTIM5PWM_1             = {0};
GPIO_Handler_t HandlerTIM3PWM_2 			= {0};
GPIO_Handler_t HandlerTIM3PWM_3				= {0};
GPIO_Handler_t HandlerTIM3PWM_4				= {0};
GPIO_Handler_t HandlerTIM4PWM_5        		= {0};
GPIO_Handler_t HandlerTIM4PWM_6				= {0};
GPIO_Handler_t HandlerTIM4PWM_7				= {0};
GPIO_Handler_t HandlerTIM4PWM_8        		= {0};
GPIO_Handler_t HandlerTIM2PWM_9        		= {0};
// Definimos los basic timer del blinky y de las banderas.
BasicTimer_Handler_t handlerBlinkyTimer 	= {0};
BasicTimer_Handler_t handlerTimer4			= {0};
// Para la conversión ADC.
ADC_Config_t adcConfig = {0};
// Se define el handler de la comunicacion serial para el USART 6 que me corresponde.
USART_Handler_t USART2Comm = {0};
PWM_Handler_t handlerPWMprueba = {0};
PWM_Handler_t handlerPWM_1 = {0};
PWM_Handler_t handlerPWM_2 = {0};
PWM_Handler_t handlerPWM_3 = {0};
PWM_Handler_t handlerPWM_4 = {0};
PWM_Handler_t handlerPWM_5 = {0};
PWM_Handler_t handlerPWM_6 = {0};
PWM_Handler_t handlerPWM_7 = {0};
PWM_Handler_t handlerPWM_8 = {0};
PWM_Handler_t handlerPWM_9 = {0};
// PARA LA CONVERSIÓN ADC: los variables y los arreglos necesarios.
uint8_t adcIsComplete = 0;
uint16_t dataADC[1] = {0};
char buffer[64] = {0};
uint8_t cont = 0;
// Number of convertions son la cantidad de canales ADC que se necesitan.
uint8_t numberOfConversion = 2;
uint16_t cont2 = 0;
unsigned int   dataADCChannel0[1];
unsigned int   dataADCChannel1[1];
unsigned int   dataADCChannel2[1];
uint8_t flag = 0;
uint8_t flag2 = 0;
char rxData = 0;
char bufferData[64] = "JoyStick testing...";
//Definición de las cabeceras de las funciones del main
void initHardware(void);
void pwmSignalSwitch(void);
uint16_t flagADC = {0};
uint16_t counterADC = {0};

/* Función principal del programa */
int main(void){

	/* inicialización de todos los elementos del sistema */
	initHardware();
	writeMsg(&USART2Comm, bufferData);
	/* Loop infinito */
	while(1){
		pwmSignalSwitch();
		if(flagADC){
			sprintf(buffer, "Channel X = %u , Channel Y = %u, Channel Z = %u \n", dataADCChannel0[0], dataADCChannel1[0], dataADCChannel2[0]);
			writeMsg(&USART2Comm, buffer);
			rxData = 0;
			flagADC = 0;
		}

	}
	return 0;
}// Final del main

// Función donde se configuran los pimsgToSendnes en general.
void initHardware(void){

	// Se desactiva el reloj HSE porque PH0 está conectado a un oscilador HSE.
	RCC->CR &= ~(RCC_CR_HSEON);

	handlerStateLED.pGPIOx                               	= GPIOH;
	handlerStateLED.GPIO_PinConfig.GPIO_PinNumber 			= PIN_1;
	handlerStateLED.GPIO_PinConfig.GPIO_PinMode 			= GPIO_MODE_OUT;
	handlerStateLED.GPIO_PinConfig.GPIO_PinOPType 			= GPIO_OTYPE_PUSHPULL;
	handlerStateLED.GPIO_PinConfig.GPIO_PinSpeed 			= GPIO_OSPEED_FAST;
	handlerStateLED.GPIO_PinConfig.GPIO_PinPuPdControl 		= GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerStateLED);

	/* Configuración del TIM2 para que haga un blinky cada 250 ms */
	handlerBlinkyTimer.ptrTIMx 								= TIM2;
	handlerBlinkyTimer.TIMx_Config.TIMx_mode 				= BTIMER_MODE_UP;
	handlerBlinkyTimer.TIMx_Config.TIMx_speed				= BTIMER_SPEED_1ms;
	handlerBlinkyTimer.TIMx_Config.TIMx_period 				= 250;
	handlerBlinkyTimer.TIMx_Config.TIMx_interruptEnable 	= BTIMER_INTERRUPT_ENABLE;
	BasicTimer_Config(&handlerBlinkyTimer);

	/* Configuración del USART */
	// Transmisión
	handlerUSARTPINTX.pGPIOx  							= GPIOA;
	handlerUSARTPINTX.GPIO_PinConfig.GPIO_PinNumber 	= PIN_2;
	handlerUSARTPINTX.GPIO_PinConfig.GPIO_PinMode 		= GPIO_MODE_ALTFN;
	handlerUSARTPINTX.GPIO_PinConfig.GPIO_PinAltFunMode = AF7;
	GPIO_Config(&handlerUSARTPINTX);

	// Recepción
	handlerUSARTPINRX.pGPIOx 						 	= GPIOA;
	handlerUSARTPINRX.GPIO_PinConfig.GPIO_PinNumber		= PIN_3;
	handlerUSARTPINRX.GPIO_PinConfig.GPIO_PinMode 		= GPIO_MODE_ALTFN;
	handlerUSARTPINRX.GPIO_PinConfig.GPIO_PinAltFunMode = AF7;
	GPIO_Config(&handlerUSARTPINRX);

	// Para el USART 6
	USART2Comm.ptrUSARTx 					= USART2;
	USART2Comm.USART_Config.USART_baudrate 	= USART_BAUDRATE_115200;
	USART2Comm.USART_Config.USART_datasize 	= USART_DATASIZE_8BIT;
	USART2Comm.USART_Config.USART_parity 	= USART_PARITY_NONE;
	USART2Comm.USART_Config.USART_mode 		= USART_MODE_RXTX;
	USART2Comm.USART_Config.USART_stopbits 	= USART_STOPBIT_1;
	USART2Comm.USART_Config.USART_enableIntRX = USART_RX_INTERRUP_ENABLE;

	// Se carga lo hecho sobre el USART
	USART_Config(&USART2Comm);

	/* Configuración ADC */
	// Cargando la configuración para la conversación ADC
	adcConfig.dataAlignment			= ADC_ALIGNMENT_RIGHT;
	adcConfig.resolution			= ADC_RESOLUTION_12_BIT;
	adcConfig.samplingPeriod		= ADC_SAMPLING_PERIOD_28_CYCLES;
	adcConfig.AdcEventType			= TIMER_ADC_EVENT;
	adcConfig.AdcChannelEvent		= TIM5_CH3;
	adcConfig.adcMultiChannel[0] 	= ADC_CHANNEL_1;
	adcConfig.adcMultiChannel[1]	= ADC_CHANNEL_4;
	adcConfig.adcMultiChannel[2]	= ADC_CHANNEL_0;
	adcMultiChannel(&adcConfig, 3);
	adcConfigEvents(&adcConfig);

	// handler PWM
	handlerPWMprueba.ptrTIMx           	  =   TIM5;
	handlerPWMprueba.config.channel       =   PWM_CHANNEL_3;
	handlerPWMprueba.config.duttyCicle    =   10000;
	handlerPWMprueba.config.periodo       =   20000;
	handlerPWMprueba.config.prescaler     =   16;
	pwm_Config(&handlerPWMprueba);
	enableOutput(&handlerPWMprueba);
	startPwmSignal(&handlerPWMprueba);

	// GPIO TIM 3 CC4
	HandlerTIM5PWM_1.pGPIOx          					= GPIOB;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinNumber  	= PIN_1;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM5PWM_1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM5PWM_1);
	// Izquierda
	handlerPWM_1.ptrTIMx           	  =   TIM3;
	handlerPWM_1.config.channel       =   PWM_CHANNEL_4;
	handlerPWM_1.config.duttyCicle    =   10000;
	handlerPWM_1.config.periodo       =   20000;
	handlerPWM_1.config.prescaler     =   16;
	pwm_Config(&handlerPWM_1);

	// GPIO TIM 3 CC3
	HandlerTIM3PWM_2.pGPIOx          					= GPIOB;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinNumber  	= PIN_0;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM3PWM_2.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM3PWM_2);
	// Derecha
	handlerPWM_2.ptrTIMx           	  =   TIM3;
	handlerPWM_2.config.channel       =   PWM_CHANNEL_3;
	handlerPWM_2.config.duttyCicle    =   10000;
	handlerPWM_2.config.periodo       =   20000;
	handlerPWM_2.config.prescaler     =   16;
	pwm_Config(&handlerPWM_2);

	// GPIO TIM 3 CC1
	HandlerTIM3PWM_3.pGPIOx          					= GPIOA;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinNumber  	= PIN_6;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM3PWM_3.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM3PWM_3);
	// Arriba
	handlerPWM_3.ptrTIMx           	  =   TIM3;
	handlerPWM_3.config.channel       =   PWM_CHANNEL_1;
	handlerPWM_3.config.duttyCicle    =   10000;
	handlerPWM_3.config.periodo       =   20000;
	handlerPWM_3.config.prescaler     =   16;
	pwm_Config(&handlerPWM_3);

	// GPIO TIM 3 CC2
	HandlerTIM3PWM_4.pGPIOx          					= GPIOA;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinNumber  	= PIN_7;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM3PWM_4.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM3PWM_4);
	// Abajo
	handlerPWM_4.ptrTIMx           	  =   TIM3;
	handlerPWM_4.config.channel       =   PWM_CHANNEL_2;
	handlerPWM_4.config.duttyCicle    =   10000;
	handlerPWM_4.config.periodo       =   20000;
	handlerPWM_4.config.prescaler     =   16;
	pwm_Config(&handlerPWM_4);

	// GPIO TIM 4 CC1
	HandlerTIM4PWM_5.pGPIOx          					= GPIOB;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinNumber  	= PIN_6;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM4PWM_5.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM4PWM_5);
	// DIAGONAL X
	handlerPWM_5.ptrTIMx           	  =   TIM4;
	handlerPWM_5.config.channel       =   PWM_CHANNEL_1;
	handlerPWM_5.config.duttyCicle    =   10000;
	handlerPWM_5.config.periodo       =   20000;
	handlerPWM_5.config.prescaler     =   16;
	pwm_Config(&handlerPWM_5);

	// GPIO TIM 4 CC2
	HandlerTIM4PWM_6.pGPIOx          					= GPIOB;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinNumber  	= PIN_7;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM4PWM_6.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM4PWM_6);
	// DIAGONAL Y
	handlerPWM_6.ptrTIMx           	  =   TIM4;
	handlerPWM_6.config.channel       =   PWM_CHANNEL_2;
	handlerPWM_6.config.duttyCicle    =   10000;
	handlerPWM_6.config.periodo       =   20000;
	handlerPWM_6.config.prescaler     =   16;
	pwm_Config(&handlerPWM_6);

	// GPIO TIM 4 CC3
	HandlerTIM4PWM_7.pGPIOx          					= GPIOB;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinNumber  	= PIN_8;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM4PWM_7.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM4PWM_7);
	// DIAGONAL Y
	handlerPWM_7.ptrTIMx           	  =   TIM4;
	handlerPWM_7.config.channel       =   PWM_CHANNEL_3;
	handlerPWM_7.config.duttyCicle    =   10000;
	handlerPWM_7.config.periodo       =   20000;
	handlerPWM_7.config.prescaler     =   16;
	pwm_Config(&handlerPWM_7);

	// GPIO TIM 4 CC4
	HandlerTIM4PWM_8.pGPIOx          					= GPIOB;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinNumber  	= PIN_9;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
	HandlerTIM4PWM_8.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;

	GPIO_Config(&HandlerTIM4PWM_8);
	// DIAGONAL Y
	handlerPWM_8.ptrTIMx           	  =   TIM4;
	handlerPWM_8.config.channel       =   PWM_CHANNEL_4;
	handlerPWM_8.config.duttyCicle    =   10000;
	handlerPWM_8.config.periodo       =   20000;
	handlerPWM_8.config.prescaler     =   16;
	pwm_Config(&handlerPWM_8);

//	// GPIO TIM 4 CC4
//	HandlerTIM2PWM_9.pGPIOx          					= GPIOA;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinNumber  	= PIN_0;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinMode    	= GPIO_MODE_ALTFN;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinOPType  	= GPIO_OTYPE_PUSHPULL;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEED_FAST;
//	HandlerTIM2PWM_9.GPIO_PinConfig.GPIO_PinAltFunMode  = AF1;
//
//	GPIO_Config(&HandlerTIM2PWM_9);
//	// DIAGONAL Y
//	handlerPWM_9.ptrTIMx           	  =   TIM2;
//	handlerPWM_9.config.channel       =   PWM_CHANNEL_1;
//	handlerPWM_9.config.duttyCicle    =   10000;
//	handlerPWM_9.config.periodo       =   20000;
//	handlerPWM_9.config.prescaler     =   16;
//	pwm_Config(&handlerPWM_9);


} // Fin initHardware

void pwmSignalSwitch(void){
	if (dataADCChannel0[0] <= 10 && (dataADCChannel1[0] >= 2000 && dataADCChannel1[0] <= 2150)){
		updateDuttyCycle(&handlerPWM_1, 10000);
		enableOutput(&handlerPWM_1);
		startPwmSignal(&handlerPWM_1);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if (dataADCChannel0[0] >= 4000 && (dataADCChannel1[0] >= 2000 && dataADCChannel1[0] <= 2150)){
		updateDuttyCycle(&handlerPWM_2, 10000);
		enableOutput(&handlerPWM_2);
		startPwmSignal(&handlerPWM_2);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);#include "PwmDriver.h"

		/**/
		void pwm_Config(PWM_Handler_t *ptrPwmHandler){

			/* 1. Activar la señal de reloj del periférico requerido */
			if(ptrPwmHandler->ptrTIMx == TIM2){
				RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
			}
			else if(ptrPwmHandler->ptrTIMx == TIM3){
				RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
			}
			else if(ptrPwmHandler->ptrTIMx == TIM4){
				RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
			}
			else if(ptrPwmHandler->ptrTIMx == TIM5){
				RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;
			}
			else{
				__NOP();
			}

			/* 1. Cargamos la frecuencia deseada */
			setFrequency(ptrPwmHandler);

			/* 2. Cargamos el valor del dutty-Cycle*/
			setDuttyCycle(ptrPwmHandler);

			/* 2a. Estamos en UP_Mode, el limite se carga en ARR y se comienza en 0 */
			ptrPwmHandler->ptrTIMx->CR1 &= ~TIM_CR1_DIR;

			/* 3. Configuramos los bits CCxS del registro TIMy_CCMR1, de forma que sea modo salida
			 * (para cada canal hay un conjunto CCxS)
			 *
			 * 4. Además, en el mismo "case" podemos configurar el modo del PWM, su polaridad...
			 *
			 * 5. Y además activamos el preload bit, para que cada vez que exista un update-event
			 * el valor cargado en el CCRx será recargado en el registro "shadow" del PWM */
			switch(ptrPwmHandler->config.channel){
			case PWM_CHANNEL_1:{
				// Seleccionamos como salida el canal
				ptrPwmHandler->ptrTIMx->CCMR1 &= ~(TIM_CCMR1_CC1S);

				// Configuramos el canal como PWM
				ptrPwmHandler->ptrTIMx->CCMR1 |= (0b110 << TIM_CCMR1_OC1M_Pos);

				// Activamos la funcionalidad de pre-load
				ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC1PE;

				break;
			}

			case PWM_CHANNEL_2:{
				// Seleccionamos como salida el canal
				ptrPwmHandler->ptrTIMx->CCMR1 &= ~(TIM_CCMR1_CC2S);

				// Configuramos el canal como PWM
				ptrPwmHandler->ptrTIMx->CCMR1 |= (0b110 << TIM_CCMR1_OC2M_Pos);

				// Activamos la funcionalidad de pre-load
				ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC2PE;
				break;
			}

			case PWM_CHANNEL_3:{
				// Seleccionamos como salida el canal
				ptrPwmHandler->ptrTIMx->CCMR2 &= ~(TIM_CCMR2_CC3S);

				// Configuramos el canal como PWM
				ptrPwmHandler->ptrTIMx->CCMR2 |= (0b110 << TIM_CCMR2_OC3M_Pos);

				// Activamos la funcionalidad de pre-load
				ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC3PE;
				break;
			}

			case PWM_CHANNEL_4:{
				// Seleccionamos como salida el canal
				ptrPwmHandler->ptrTIMx->CCMR2 &= ~(TIM_CCMR2_CC4S);

				// Configuramos el canal como PWM
				ptrPwmHandler->ptrTIMx->CCMR2 |= (0b110 << TIM_CCMR2_OC4M_Pos);

				// Activamos la funcionalidad de pre-load
				ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC4PE;
				break;
			}

			default:{
				break;
			}

			}// fin del switch-case

			/* 6. Activamos la salida seleccionada */
			enableOutput(ptrPwmHandler);

			/*7. Configuramos la interrupciones*/
			//Estas interrupciones se van a ejecutar cada periodo del PWM
			//Utilizando los callbacks de los basic timers

			//Deshabilitamos la interrupciones globales
			__disable_irq();

			//7.1 Reseteamos el DIER por si las moscas
			ptrPwmHandler->ptrTIMx->DIER = 0;

			//7.2 Revisamos si van a haber o no interrupciones
			if (ptrPwmHandler->config.interruption == PWM_INTERRUPT_ENABLE){

				//Las interrupciones estan habilitadas
				ptrPwmHandler->ptrTIMx->DIER |= TIM_DIER_UIE;
			}
			else{
				//Las interrupciones estan deshabilitadas
				ptrPwmHandler->ptrTIMx->DIER &= ~TIM_DIER_UIE;
			}

			/*7.3 Activamos el canal del sistema NVIC para que lea la interrupción*/
			if (ptrPwmHandler->ptrTIMx == TIM2) {
				// Activando en NVIC para la interrupción del TIM2
				NVIC_EnableIRQ(TIM2_IRQn);
			} else if (ptrPwmHandler->ptrTIMx == TIM3) {
				// Activando en NVIC para la interrupción del TIM3
				NVIC_EnableIRQ(TIM3_IRQn);
			} else if (ptrPwmHandler->ptrTIMx == TIM4) {
				// Activando en NVIC para la interrupción del TIM4
				NVIC_EnableIRQ(TIM4_IRQn);
			} else if (ptrPwmHandler->ptrTIMx == TIM5) {
				// Activando en NVIC para la interrupción del TIM5
				NVIC_EnableIRQ(TIM5_IRQn);
			} else {
				__NOP();
			}

			/* 7.4 Volvemos a activar las interrupciones del sistema */
			__enable_irq();

		}

		/* Función para activar el Timer y activar todo el módulo PWM */
		void startPwmSignal(PWM_Handler_t *ptrPwmHandler) {
			ptrPwmHandler->ptrTIMx->CR1 |= TIM_CR1_CEN;
		}

		/* Función para desactivar el Timer y detener todo el módulo PWM*/
		void stopPwmSignal(PWM_Handler_t *ptrPwmHandler) {
			ptrPwmHandler->ptrTIMx->CR1 &= ~TIM_CR1_CEN;
		}

		/* Función encargada de activar cada uno de los canales con los que cuenta el TimerX */
		void enableOutput(PWM_Handler_t *ptrPwmHandler) {
			switch (ptrPwmHandler->config.channel) {
			case PWM_CHANNEL_1: {
				// Activamos la salida del canal 1
				ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC1E;
				break;
			}

			case PWM_CHANNEL_2: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC2E;
				break;
			}

			case PWM_CHANNEL_3: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC3E;

				break;
			}

			case PWM_CHANNEL_4: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC4E;

				break;
			}

			default: {
				break;
			}
			}
		}

		void offOutput(PWM_Handler_t *ptrPwmHandler) {
			switch (ptrPwmHandler->config.channel) {
			case PWM_CHANNEL_1: {
				// Activamos la salida del canal 1
				ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC1E;
				break;
			}

			case PWM_CHANNEL_2: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC2E;
				break;
			}

			case PWM_CHANNEL_3: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC3E;

				break;
			}

			case PWM_CHANNEL_4: {
				// Activamos la salida del canal 2
				ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC4E;

				break;
			}

			default: {
				break;
			}
			}
		}

		/*
		 * La frecuencia es definida por el conjunto formado por el preescaler (PSC)
		 * y el valor límite al que llega el Timer (ARR), con estos dos se establece
		 * la frecuencia.
		 * */
		void setFrequency(PWM_Handler_t *ptrPwmHandler){

			// Cargamos el valor del prescaler, nos define la velocidad (en ns) a la cual
			// se incrementa el Timer
			ptrPwmHandler->ptrTIMx->PSC = ptrPwmHandler->config.prescaler -1;

			// Cargamos el valor del ARR, el cual es el límite de incrementos del Timer
			// antes de hacer un update y reload.
			ptrPwmHandler->ptrTIMx->ARR = ptrPwmHandler->config.periodo;
		}


		/* Función para actualizar la frecuencia, funciona de la mano con setFrequency */
		void updateFrequency(PWM_Handler_t *ptrPwmHandler, uint16_t newFreq){
			// Actualizamos el registro que manipula el periodo
		    ptrPwmHandler->config.periodo = newFreq;

			// Llamamos a la fucnión que cambia la frecuencia
		    setFrequency(ptrPwmHandler);
		}

		/* El valor del dutty debe estar dado en valores de %, entre 0% y 100%*/
		void setDuttyCycle(PWM_Handler_t *ptrPwmHandler){

			// Seleccionamos el canal para configurar su dutty
			switch(ptrPwmHandler->config.channel){
			case PWM_CHANNEL_1:{
				ptrPwmHandler->ptrTIMx->CCR1 = ptrPwmHandler->config.duttyCicle;

				break;
			}

			case PWM_CHANNEL_2:{
				ptrPwmHandler->ptrTIMx->CCR2 = ptrPwmHandler->config.duttyCicle;
				break;
			}

			case PWM_CHANNEL_3:{
				ptrPwmHandler->ptrTIMx->CCR3 = ptrPwmHandler->config.duttyCicle;
				break;
			}

			case PWM_CHANNEL_4:{
				ptrPwmHandler->ptrTIMx->CCR4 = ptrPwmHandler->config.duttyCicle;
				break;
			}

			default:{
				break;
			}

			}// fin del switch-case

		}


		/* Función para actualizar el Dutty, funciona de la mano con setDuttyCycle */
		void updateDuttyCycle(PWM_Handler_t *ptrPwmHandler, uint16_t newDutty){
			// Actualizamos el registro que manipula el dutty
			ptrPwmHandler->config.duttyCicle = newDutty;

			// Llamamos a la fucnión que cambia el dutty y cargamos el nuevo valor
			setDuttyCycle(ptrPwmHandler);
		}




		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel0[0] >= 2000 && dataADCChannel0[0] <= 2150) && dataADCChannel1[0] >= 4000){
		updateDuttyCycle(&handlerPWM_3, 10000);
		enableOutput(&handlerPWM_3);
		startPwmSignal(&handlerPWM_3);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel0[0] >= 2000 && dataADCChannel0[0] <= 2150) && dataADCChannel1[0] <= 10){
		updateDuttyCycle(&handlerPWM_4, 10000);
		enableOutput(&handlerPWM_4);
		startPwmSignal(&handlerPWM_4);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel1[0] >= 4000 && dataADCChannel1[0] <= 4150) && dataADCChannel0[0] <= 10){
		updateDuttyCycle(&handlerPWM_5, 10000);
		enableOutput(&handlerPWM_5);
		startPwmSignal(&handlerPWM_5);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel1[0] >= 0 && dataADCChannel1[0] <= 20) && dataADCChannel0[0] <= 20){
		updateDuttyCycle(&handlerPWM_6, 10000);
		enableOutput(&handlerPWM_6);
		startPwmSignal(&handlerPWM_6);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel0[0] >= 4000 && dataADCChannel0[0] <= 4150) && (dataADCChannel1[0] >= 4000 && dataADCChannel1[0] <= 4150)){
		updateDuttyCycle(&handlerPWM_7, 10000);
		enableOutput(&handlerPWM_7);
		startPwmSignal(&handlerPWM_7);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel0[0] >= 4000 && dataADCChannel0[0] <= 4150) && dataADCChannel1[0] <= 20){
		updateDuttyCycle(&handlerPWM_8, 10000);
		enableOutput(&handlerPWM_8);
		startPwmSignal(&handlerPWM_8);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_9, 0);
	}else if ((dataADCChannel0[0] >= 2000 && dataADCChannel0[0] <= 2150) && (dataADCChannel1[0] >= 2000 && dataADCChannel1[0] <= 2150)){
		updateDuttyCycle(&handlerPWM_9, 10000);
		enableOutput(&handlerPWM_9);
		startPwmSignal(&handlerPWM_9);
		updateDuttyCycle(&handlerPWM_1, 0);
		updateDuttyCycle(&handlerPWM_2, 0);
		updateDuttyCycle(&handlerPWM_3, 0);
		updateDuttyCycle(&handlerPWM_4, 0);
		updateDuttyCycle(&handlerPWM_5, 0);
		updateDuttyCycle(&handlerPWM_6, 0);
		updateDuttyCycle(&handlerPWM_7, 0);
		updateDuttyCycle(&handlerPWM_8, 0);
	}
}

/* Timer que gobierna el blinky del led de estado */
void BasicTimer2_Callback(void){
	if(counterADC == 5){
		counterADC = 0;
	}
	flagADC = 1;
	counterADC++;
	GPIOxTooglePin(&handlerStateLED);
}



// Callback para los comandos del USART.
void usart2Rx_Callback(void){
	rxData = getRxData();
}

// Esta función controla el contador del ADC.(Hace las veces de callback)
void adcComplete_Callback(void){
	if(cont == 0){
		dataADCChannel0[cont2] = getADC();
	}
	else if (cont == 1){
		dataADCChannel1[cont2] = getADC();
	}else{
		dataADCChannel2[cont2] = getADC();
		cont2++;
	}
	cont++;
	if(cont2 == 1){
		cont2 = 0;
	}
	if(cont == 3){
		cont = 0;
	}
}
