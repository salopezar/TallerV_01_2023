/*
 * RTCDriver.c
 *
 *  Created on: 7/06/2023
 *      Author: santiago
 */

#include "RTCDriver.h"


/* Driver RTC usando el cristal LSE*/

// Definicion de arreglos para readTime y read_Date
uint8_t time[6] = {0};
uint8_t date[5] = {0};

// Variables donde se almacenan los datos del tiempo
uint8_t RTC_HoursU   = 0;
uint8_t RTC_HoursT   = 0;
uint8_t RTC_MinutesU = 0;
uint8_t RTC_MinutesT = 0;
uint8_t RTC_SecondsU = 0;
uint8_t RTC_SecondsT = 0;
uint8_t RTC_AmPm 	 = 0;

//Variables que almacenan los datos del calendario
uint8_t RTC_dayU 	 = 0;
uint8_t RTC_dayT  	 = 0;
uint8_t RTC_month    = 0;
uint8_t RTC_yearU	 = 0;
uint8_t RTC_yearT 	 = 0;
uint8_t RTC_wdu      = 0;

void config_RTC(RTC_Handler_t *ptrRTCHandler){

	/*Los registros RTC se encuentran protegidos contra posibles accesos de escritura, es
	 * por ello que habilitamos el reloj del APB1 que es donde se encuentra el RTC. Luego
	 * se habilita el acceso de escritura en  power control register.
	 */
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_DBP;

	/* Activamos la señal de reloj RTC
	 * Se activa el cristal externo de baja velocidad(LSE)
	 * Se Selecciona como fuente de reloj LSE para el RTC
	 */
	RCC->BDCR |= RCC_BDCR_RTCEN;
	RCC->BDCR |= RCC_BDCR_LSEON;
	RCC->BDCR |= RCC_BDCR_RTCSEL_0;

	// Se espera hasta que el LSE este listo
	while(!(RCC->BDCR & RCC_BDCR_LSERDY));

	/*Se escriben las claves dadas por el fabricante en el registro de protección contra
	 * escritura (0xCA y 0x53). De esta forma, desbloqueamos la escritura en el registro RTC
	 */
    RTC->WPR |= 0xCA;
    RTC->WPR |= 0x53;

    // Se entra en el modo de inicializacion en el registro RTC initialization and status register
    RTC->ISR |= RTC_ISR_INIT;

    // Se espera a que se active completamente el modo inicializacion
    while(!(RTC->ISR & RTC_ISR_INITF));

    /* Para generar en el reloj 1 Hz se establecen los factores de division para los prescaladores
     * sincrono y asincrono. Se coloca 127 para el asicrono y 255 para el sincrono
     */
    RTC->PRER |= 127 << RTC_PRER_PREDIV_A_Pos;
    RTC->PRER |= 255 << RTC_PRER_PREDIV_S_Pos;

    /*Cuando se establece el bit de control BYPSHAD, se omite la sombra de registros. Como se
     * establece 1 en este bit, el registro se deshabilita y se toman directamente las escrituras
     * de fecha y hora
     */
    RTC->CR |= RTC_CR_BYPSHAD;

    // Se reinician los registros de hora y fecha (RTC_TR y RTC_DR)
    RTC->TR = 0;
    RTC->DR = 0;

    // Elegimos el formato de hora AM/PM
    RTC->CR |= RTC_CR_FMT;

    /* El registro time register se encuentra en formato BCD (codigo decimal binario), por lo tanto es
     * necesario separar el valor ingresado en el handler en decenas y unidades
     */
    // Para las horas
    RTC->TR |= ptrRTCHandler->RTC_Hours/10 << RTC_TR_HT_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Hours%10 << RTC_TR_HU_Pos;

    //Para los minutos
    RTC->TR |= ptrRTCHandler->RTC_Minutes/10 << RTC_TR_MNT_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Minutes%10 << RTC_TR_MNU_Pos;

    //Para los segundos
    RTC->TR |= ptrRTCHandler->RTC_Seconds/10  << RTC_TR_ST_Pos;
    RTC->TR |= ptrRTCHandler->RTC_Seconds%10 << RTC_TR_SU_Pos;

    //Para el formato AM-PM
    RTC->TR |= ptrRTCHandler->RTC_AmPm << RTC_TR_PM_Pos;

    /* Realizamos la configuracion de la fecha en el registro RTC date register. Tambien se encuentra
     * en formato BCD, por lo tanto, es necesario separar el valor ingresado en el handler en decenas
     * y unidades.
     */

    //Para los meses
    RTC->DR |= ptrRTCHandler->RTC_Months%10 << RTC_DR_MU_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Months/10 << RTC_DR_MT_Pos;

    //Para los dias
    RTC->DR |= ptrRTCHandler->RTC_Days/10 << RTC_DR_DT_Pos;
    RTC->DR |= ptrRTCHandler->RTC_Days%10 << RTC_DR_DU_Pos;

    //SE ingresa el día de la semana en BCD
    RTC->DR |= ptrRTCHandler->RTC_Wdu<< RTC_DR_WDU_Pos;

    /*El sistema por defecto tiene la fecha del año 2000, de este modo se resta 2000 al valor del handler
     * y se realiza la separacion de decenas y unidades porque los años se encuentran en formato BCD.
     */
    RTC->DR |= ((ptrRTCHandler->RTC_Years -2000)%10) << RTC_DR_YU_Pos;
    RTC->DR |= (ptrRTCHandler->RTC_Years - 2000)/10 << RTC_DR_YT_Pos;

    // Activamos nuevamente el real time clock
    RCC->BDCR |= RCC_BDCR_RTCEN;

    // Salimos del modo de inicializacion borrando el bit de inicio
    RTC->ISR &= ~RTC_ISR_INIT;

    // Se habilita la proteccion de bits
    PWR->CR &= ~ PWR_CR_DBP;

    // Escribir una clave incorrecta reactiva la protección contra escritura
    RTC->WPR = (0xFF);

}// Fin config_RTC

// Funcion que entrega un puntero para almacenar los resultados en el arreglo Time
uint8_t* readTime(void){

	/*Extraemos el dato de los registros haciendo uso de una mascara y lo desplazamos a
	 * la primera posicion
	*/

	//para las horas
	RTC_HoursU = ((RTC->TR & RTC_TR_HU_Msk)>>RTC_TR_HU_Pos);
    RTC_HoursT = ((RTC->TR & RTC_TR_HT_Msk)>> RTC_TR_HT_Pos);

    // para los minutos
    RTC_MinutesU = ((RTC->TR & RTC_TR_MNU_Msk)>>RTC_TR_MNU_Pos);
    RTC_MinutesT = ((RTC->TR & RTC_TR_MNT_Msk)>>RTC_TR_MNT_Pos);

    // para los segundos
    RTC_SecondsU = ((RTC->TR & RTC_TR_SU_Msk)>>RTC_TR_SU_Pos);
    RTC_SecondsT = ((RTC->TR & RTC_TR_ST_Msk)>>RTC_TR_ST_Pos);

    // Para el formato AM-PM
    RTC_AmPm = ((RTC->TR & RTC_TR_PM_Msk)>>RTC_TR_PM_Pos);

    //Se almacenan los datos en el arreglo Time
    time[0] = RTC_SecondsU;
    time[1] = RTC_SecondsT;
    time[2] = RTC_MinutesU;
    time[3] = RTC_MinutesT;
    time[4] = RTC_HoursU;
    time[5] = RTC_HoursT;
    time[6] = RTC_AmPm;

     return time;

}// Fin funcion readTime

// Funcion que entrega un puntero para almacenar los resultados en el arreglo Date
uint8_t* readDate(void){

	/*Extraemos el dato de los registros haciendo uso de una mascara y lo desplazamos a
	 * la primera posicion
	 */

	// Para los dias
    RTC_dayT = ((RTC->DR & RTC_DR_DT_Msk)>> RTC_DR_DT_Pos);
    RTC_dayU = ((RTC->DR & RTC_DR_DU_Msk)>>RTC_DR_DU_Pos);

    //Para el año
    RTC_yearU = ((RTC->DR & RTC_DR_YU_Msk)>>RTC_DR_YU_Pos);
    RTC_yearT = ((RTC->DR & RTC_DR_YT_Msk)>>RTC_DR_YT_Pos);

    //Para el mes
    RTC_month = (((RTC->DR & RTC_DR_MT_Msk)>>RTC_DR_MT_Pos)*10) + (((RTC->DR & RTC_DR_MU_Msk)>>RTC_DR_MU_Pos)%10);

    // Dias de la semana
    RTC_wdu = (RTC->DR & RTC_DR_WDU_Msk)>>RTC_DR_WDU_Pos;

    // Se almacenan los datos en el arreglo date
    date[0] = RTC_dayU;
    date[1] = RTC_dayT;
    date[2] = RTC_month;
    date[3] = RTC_yearU;
    date[4] = RTC_yearT;
    date[5] = RTC_wdu;

    return date;

}// Fin funcion readDate


