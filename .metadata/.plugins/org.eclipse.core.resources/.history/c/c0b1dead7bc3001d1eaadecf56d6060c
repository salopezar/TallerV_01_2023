/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Santiago López Aranzazu - CC. 1007429871
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* ************* COMENTARIO GENERAL PARA INTRODUCIR EL CÓDIGO BASE ****************
 *
 * Con este programa se desea mostrar el uso básico de los registros que controlan
 * al Micro (SFR) y la forma adecuada para utilizar los operadores &, |, ~ y =, para
 * cambiar la configuración de algún registro.
 * También es importante para entender la utilidad de los números BIN y HEX.
 *
 * HAL-> Hardware Abstraction Layer.
 *
 * Este programa introduce el periférico más simple que tiene el microcontrolador, que es
 * el encargado de manejar los pines de cada puerto.
 *
 * Cada PINx de cada puerto GPIO puede desarrollar funciones básicas de tipo entrada
 * y salida de datos digitales (1 ó 0), además se les puede asignar funciones especiales
 * que generalmente están ligadas a otro periférico adicional (se verá más adelante).
 *
 * De igual forma, varias caaracterísticas pueden ser configuradas para cada PINx
 * específico, como son:
 *
 * -Velocidad de respuesta.
 * -Tipo de entrada.
 * -Tipo de salida.
 * -Entrada análoga.
 *
 * Debemos definir entonces todos los registros que manejan el periférico GPIOx y luego
 * crear algunas funciones para utilizar adecuadamente el equipo.
 *
 * ************************** TAREA #2 - TALLER V - 2023_01 **************************************
 *
 * El presente programa es una compilación de las configuraciones básicas que se deben tener
 * en cuenta para manipular los registros que utiliza el periférico GPIO (que es el originalmente
 * más simple del microcontrolador) para manejar los pines de cada puerto, de allí su nombre que
 * indica que es de "propósito general".
 * Los códigos base de las cabeceras (.h) y los archivos (.c) fueron tomados de las indicaciones
 * de clase del curso de taller V.
 * La metodología escogida por quien desarrolla el presente consiste en desglosar cada uno de los
 * (3) numerales con sus respectivos subindices uno a uno para conseguir una mejor claridad en la
 * explicación del procedimiento que se considera adecuado para dar solución en cada ítem, por
 * tanto, señor usuario, por favor considere los siguientes bloques:
 *
 * *************************************** PUNTO 1 ***********************************************
 *
 * En la línea 161 del archivo correspondiente al GPIOxDriver.c se declara una función GPIO_ReadPin()
 * de 32 Bits que originalmente está diseñada para leer el estado de un PIN específico y recibe parámetros
 * del tipo GPIO_Handler_t. En el enunciado de la tarea se plantea que esta función tiene un error que
 * no permite obtener el valor real que se debería leer de un PINx. Inicialmente la definición de esta
 * función estaba dada de la siguiente manera:
 *
 * uint32_t GPIO_ReadPin(GPIO_Handler_t *pPinHandler){
 *
 *	Se crea una variable auxiliar de 32 bits que después se busca retornar.
 *	uint32_t pinValue = 0;
 *
 *	Luego, la variable pinValue sirve para almacenar la lectura del input data register (IDR) para luego
 *	desplazar el registro mediante una operación bitwise, haciendo un shift a la derecha (>>) tantas
 *	veces como lo indique el PinNumber.
 *	pinValue = (pPinHandler->pGPIOx->IDR >> pPinHandler->GPIO_PinConfig.GPIO_PinNumber);
 *
 *	return pinValue;
 *}
 *
 *El problema que se detecta con los anteriores comandos de código es que al desplazar este registro
 *a la derecha, no se están limpiando los demás bits que no corresponden al bit menos significativo que
 *es el que realmente se quiere leer mediante la función ya definida anteriormente. Además, debe tenerse
 *en cuenta que dentro del input data register se tienen 16 Bits que están inicialmente reservados, por
 *tanto no puede observarse la información existente en ellos.
 *
 *
 */

//Libreria para los tipos de variables
#include <stdint.h>

#include <stm32f411xx_hal.h>
#include <GPIOxDriver.h>

/*Función principal del programa. Es acá donde se ejecuta todo */
int main(void){

	//Definimos el Handler para el PIN que deseamos configurar
	GPIO_Handler_t handlerUserLedPin = {0};

	//Se decide trabajar con el puerto GPIOA
	handlerUserLedPin.pGPIOx 								= GPIOA;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;                //Ninguna función


	//Cargamos la configuración del pin específico
	GPIO_Config(&handlerUserLedPin);

	//Hacemos que el PIN_A5 quede encendido
	GPIO_WritePin(&handlerUserLedPin, SET);

	//Este es el ciclo principal, donde se ejecuta todo el programa
	while(1){
		NOP();
	}

}
