/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 ********************************* TAREA #3 - TALLER V *************************
 *
 * El objetivo principal de esta tarea consiste en mostrar un primer acercamiento
 * al uso de interrupciones mediante un contador numérico que se inicializa en 0
 * y va hasta el 99, que va a variar o a disminuir dependiendo del sentido de giro
 * de un encoder rotativo simple; Haciendo uso de las características de las señales
 * que se obtienen de cada una de las salidas con las que cuenta: Clock (CLK) que
 * consiste en una señal cuadrada de reloj, Data (PinDT) y el switch (Button SW). Las
 * señales CLK y PinDT originalmente están desfasadas 90°, por tanto, identificando
 * flancos de  bajada o de subida, se puede crear un programa que permita reconocer
 * mediante la superposición de estas señales, si el encoder está rotando en sentido
 * horario o antihorario. En el caso del presente, se decide configurar los condicionales
 * if para detectar estos cambios de dirección mediante flancos de bajada. En términos
 * generales, la tarea busca traducir estos cambios de dirección del encoder rotativo
 * en dos momentos principales que se valen del uso de una pantalla 7 segmentos de dos
 * dígitos: en principio, se tiene por defecto un modo que muestra en la pantalla 7
 * segmentos un contador que va desde 0 a 99 y varía de acuerdo al sentido de rotación y
 * en un segundo momento, se recrea el tradicional juego del snake para reproducir una
 * barrita LED que sigue una secuencia determinada por este sentido de giro.
*/

#include <stdint.h>
#include "stm32f4xx.h"
#include "BasicTimer.h"
#include "GPIOxDriver.h"
#include "ExtiDriver.h"

// Se define y se inicializa el LED de estado.
GPIO_Handler_t handlerBlinkyPin = {0};
// Definición del timer para el Blinky.
BasicTimer_Handler_t handlerTim2 = {0};

/* Se definen y se inicializan los elementos del ENCODER.*/
GPIO_Handler_t handlerPinDT 	= {0};
GPIO_Handler_t handlerCLK		= {0};
GPIO_Handler_t handlerButtonSW	= {0};

// Elementos para las interrupciones del encoder.
EXTI_Config_t handlerExtiCLK 		= {0};
EXTI_Config_t handlerExtiButtonSW 	= {0};
EXTI_Config_t handlerExtiDT 		= {0};

// Se declaran las variables necesarias para las banderas
char flagClock 		= 0;
char flagButtonSW 	= 0;
char flagPinDT 		= 0;

// Definición del contador
uint8_t counter = 0;

//Definición de elementos necesarios para el DISPLAY
GPIO_Handler_t handlerDisplay_Izq = {0};
GPIO_Handler_t handlerDisplay_Der = {0};
GPIO_Handler_t handlerPin_a = {0};
GPIO_Handler_t handlerPin_b = {0};
GPIO_Handler_t handlerPin_c = {0};
GPIO_Handler_t handlerPin_d = {0};
GPIO_Handler_t handlerPin_e = {0};
GPIO_Handler_t handlerPin_f = {0};
GPIO_Handler_t handlerPin_g = {0};

BasicTimer_Handler_t handlerDisplayTimer = {0};

void showNumber (void);
void showDisplay(uint8_t numero);



// Función que inicializa el sistema.
void init_Hardware(void);
// Funciones para el timer del encoder y declaración de los callback.
void BasicTimer2_Callback(void);
void callback_extInt11(void);
void callback_extInt15(void);
void BasicTimer5_Callback(void);


/* Se ajustan los parámetros
 * de la función central del programa
 */
int main(void){

	//Se inician todos los elementos necesarios del sistema.
	init_Hardware();

	while(1){
		/* Se definen las condiciones generales para la rotación del ENCODER */
		// Se considera que cuando el encoder gire en sentido horario,
		// hay incremento en el valor.
		if(flagClock){
			if((GPIO_ReadPin(&handlerPinDT)) == 1){
			counter++;
			}
			/* Se considera que cuando el encoder gire en sentido antihorario,
		 	   hay disminución en el valor. */
			else if ((GPIO_ReadPin(&handlerPinDT)) == 0){
				counter--;
			}
			// Se baja la bandera del exti.
			flagClock = 0;
			// Se restringe el intervalo de operación del contador entre 0 y 99.
			if(counter <= 0){
			counter = 0;
			}
			else if (counter >= 99) {
			       counter = 99;
			}

		}
		showNumber();
		showDisplay();


}
}

// Se crea esta función para mostrar las unidades y las decenas en el display.
void showNumber (void){
	if(GPIO_ReadPin(&handlerDisplay_Izq) == RESET){
		showDisplay(counter/10);
	}else{
		showDisplay(counter%10);
	}
}

/* Se define la función que va a configurar los segmentos en el display de acuerdo
   al número. */
void showDisplay(uint8_t numero){
	switch(numero){
	case 0:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, RESET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, SET);
		break;
	case 1:
		GPIO_WritePin(&handlerPin_a, SET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, SET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, SET);
		GPIO_WritePin(&handlerPin_g, SET);
		break;
	case 2:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, SET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, RESET);
		GPIO_WritePin(&handlerPin_f, SET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 3:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, SET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 4:
		GPIO_WritePin(&handlerPin_a, SET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, SET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 5:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, SET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 6:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, SET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, RESET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 7:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, SET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, SET);
		GPIO_WritePin(&handlerPin_g, SET);
		break;
	case 8:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, RESET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;
	case 9:
		GPIO_WritePin(&handlerPin_a, RESET);
		GPIO_WritePin(&handlerPin_b, RESET);
		GPIO_WritePin(&handlerPin_c, RESET);
		GPIO_WritePin(&handlerPin_d, RESET);
		GPIO_WritePin(&handlerPin_e, SET);
		GPIO_WritePin(&handlerPin_f, RESET);
		GPIO_WritePin(&handlerPin_g, RESET);
		break;

	}

}

// Es la función con la que se establecen las configuraciones generales del sistema.
void init_Hardware(void){

	  /* Configuración del LED de estado que indica el funcionamiento del programa */
		handlerBlinkyPin.pGPIOx 								= GPIOA;
		handlerBlinkyPin.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;
		handlerBlinkyPin.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerBlinkyPin.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerBlinkyPin.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerBlinkyPin.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se selecciona el TIMER que se elegió trabajar en el programa.
		handlerTim2.ptrTIMx 	= TIM2;

		// Configuración general en que se va a manejar el timer.
		handlerTim2.TIMx_Config.TIMx_mode			= BTIMER_MODE_UP;
		handlerTim2.TIMx_Config.TIMx_period			= 250;
		handlerTim2.TIMx_Config.TIMx_speed			= BTIMER_SPEED_1ms;

		// Se carga lo que se hizo sobre el pin A5
		GPIO_Config(&handlerBlinkyPin);
		GPIO_WritePin(&handlerBlinkyPin, SET);

		/* Se carga ahora la configuración del TIMER */
		BasicTimer_Config(&handlerTim2);

		/* Se configuran las salidas del encoder */
		// Configuración para la salida del clock (CLK) del encoder.
		handlerCLK.pGPIOx 									= GPIOC;
		handlerCLK.GPIO_PinConfig.GPIO_PinNumber			= PIN_11;
		handlerCLK.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_IN;
		handlerCLK.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
		handlerCLK.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerCLK.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;

	    // Se carga la configuración.
		GPIO_Config(&handlerCLK);

		handlerExtiCLK.edgeType								= EXTERNAL_INTERRUPT_FALLING_EDGE;
		handlerExtiCLK.pGPIOHandler							= &handlerCLK;

	    // Cargando la configuracion del EXTI
	    extInt_Config(&handlerExtiCLK);

		/* Se configuran las salidas del encoder */
		// Configuración para la salida del DATA (DT) del encoder.
		handlerPinDT.pGPIOx 								= GPIOC;
		handlerPinDT.GPIO_PinConfig.GPIO_PinNumber			= PIN_12;
		handlerPinDT.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
		handlerPinDT.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;

	    // Se carga la configuración.
		GPIO_Config(&handlerPinDT);

		/* Se configuran las salidas del encoder */
		// Configuración para el botón (sw) del encoder.
		/*handlerButtonSW.pGPIOx 							= GPIOA;
		handlerButtonSW.GPIO_PinConfig.GPIO_PinNumber		= PIN_15;
		handlerButtonSW.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
		handlerButtonSW.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	    // Se carga la configuración.
		//GPIO_Config(&handlerButtonSW);

		handlerExtiButtonSW.edgeType						= EXTERNAL_INTERRUPT_FALLING_EDGE;
		handlerExtiButtonSW.pGPIOHandler					= &handlerCLK;

	    // Cargando la configuracion del EXTI
	    extInt_Config(&handlerExtiButtonSW);*/

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_a.pGPIOx 								= GPIOA;
		handlerPin_a.GPIO_PinConfig.GPIO_PinNumber			= PIN_4;
		handlerPin_a.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_a.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_a.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_a.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_a);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_b.pGPIOx 								= GPIOA;
		handlerPin_b.GPIO_PinConfig.GPIO_PinNumber			= PIN_1;
		handlerPin_b.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_b.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_b.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_b.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_b);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_c.pGPIOx 								= GPIOA;
		handlerPin_c.GPIO_PinConfig.GPIO_PinNumber			= PIN_10;
		handlerPin_c.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_c.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_c.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_c.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_c);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_d.pGPIOx 								= GPIOB;
		handlerPin_d.GPIO_PinConfig.GPIO_PinNumber			= PIN_3;
		handlerPin_d.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_d.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_d.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_d.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_d);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_e.pGPIOx 								= GPIOB;
		handlerPin_e.GPIO_PinConfig.GPIO_PinNumber			= PIN_4;
		handlerPin_e.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_e.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_e.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_e.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_e);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_f.pGPIOx 								= GPIOC;
		handlerPin_f.GPIO_PinConfig.GPIO_PinNumber			= PIN_2;
		handlerPin_f.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_f.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_f.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_f.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_f);

		/* Configuracion de los SEGMENTOS del DISPLAY */
		handlerPin_g.pGPIOx 								= GPIOB;
		handlerPin_g.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;
		handlerPin_g.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerPin_g.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
		handlerPin_g.GPIO_PinConfig.GPIO_PinPuPdControl	    = GPIO_PUPDR_NOTHING;
		handlerPin_g.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerPin_g);

		/* Configuracion de los switcheos de los transistores */
		handlerDisplay_Izq.pGPIOx 								= GPIOB;
		handlerDisplay_Izq.GPIO_PinConfig.GPIO_PinNumber		= PIN_2;
		handlerDisplay_Izq.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerDisplay_Izq.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerDisplay_Izq.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerDisplay_Izq.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerDisplay_Izq);

		/* Configuracion de los switcheos de los transistores */
		handlerDisplay_Der.pGPIOx 								= GPIOA;
		handlerDisplay_Der.GPIO_PinConfig.GPIO_PinNumber		= PIN_12;
		handlerDisplay_Der.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerDisplay_Der.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerDisplay_Der.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerDisplay_Der.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;

		// Se carga la configuración
		GPIO_Config(&handlerDisplay_Der);

		//Configuración del timer para el display.
		// Se selecciona el TIMER que se elegió trabajar en el programa.
		handlerDisplayTimer.ptrTIMx 	= TIM5;

		// Configuración general en que se va a manejar el timer.
		handlerDisplayTimer.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
		handlerDisplayTimer.TIMx_Config.TIMx_period				= 10;
		handlerDisplayTimer.TIMx_Config.TIMx_speed				= BTIMER_SPEED_1ms;

		/* Se carga ahora la configuración del TIMER */
		BasicTimer_Config(&handlerDisplayTimer);

}

void BasicTimer2_Callback(void){
	GPIOxTooglePin(&handlerBlinkyPin);
}

void BasicTimer5_Callback(void){
	GPIOxTooglePin(&handlerDisplay_Der);
	GPIOxTooglePin(&handlerDisplay_Izq);
}

void callback_extInt11(void){
	flagClock = 1;
}

void callback_extInt15(void){
	flagButtonSW = 1;
}

